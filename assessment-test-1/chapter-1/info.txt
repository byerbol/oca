wildcards - shortcuts;
You might think that including so many classes slows down your program, but it doesn’t. The
compiler fi gures out what’s actually needed. Which approach you choose is personal preference.
Listing the classes used makes the code easier to read, especially for new programmers. Using the
wildcard can shorten the import list. You’ll see both approaches on the exam.


Redundant Imports - for ex: System;

java.lang: automatically imported;

import java.util.Random;
import java.util.*; -- redundant because Random is imported already;

Now let’s consider some imports that don’t work:

import java.nio.*; // NO GOOD – a wildcard only matches
//class names, not "file.*Files"

import java.nio.*.*; // NO GOOD – you can only have one wildcard
//and it must be at the end

import java.nio.files.Paths.*; // NO GOOD – you cannot import methods
//only class names

import java.util.*;
import java.sql.*; // DOES NOT COMPILE

When the class is found in multiple packages, Java gives you the compiler error:
The type Date is ambiguous

In our example, the solution is easy—remove the java.sql.Date import that we don’t
need. But what do we do if we need a whole pile of other classes in the java.sql package?
import java.util.Date;
import java.sql.*;
Ah, now it works. If you explicitly import a class name, it takes precedence over any
wildcards present. Java thinks, “Okay! The programmer really wants me to assume use of
the java.util.Date class.”

One more example. What does Java do with “ties” for precedence?
import java.util.Date;
import java.sql.Date;
Java is smart enough to detect that this code is no good. As a programmer, you’ve
claimed to explicitly want the default to be both the java.util.Date and java.sql.Date
implementations. Because there can’t be two defaults, the compiler tells you:
The import java.sql.Date collides with another import statement

